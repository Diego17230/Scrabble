from itertools import product as prod
from pprint import pprint
from copy import deepcopy
letter_values = {'BLANK' : 0,'a':1 , 'b':3, 'c':3, 'd':2, 'e':1, 'f':4, 'g':2, 'h':4, 'i':1, 'j':8, 'k':5, 'l':1, 'm':3, 'n':1, 'o':1, 'p':3, 'q':10, 'r':1, 's':1, 't':1, 'u':1, 'v':8, 'w':4, 'x':8, 'y':4, 'z':10}
letter_values = {letter.upper(): num for letter, num in letter_values.items()}


class Cell:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        # Value one is letter, value two is word
        self.multipliers = [1, 1]
        self.letter = "0"

    def up(self):
        return board[self.x, self.y + 1]
    def down(self):
        return board[self.x, self.y - 1]
    def left(self):
        return board[self.x - 1, self.y]
    def right(self):
        return board[self.x + 1, self.y]
    
    def __repr__(self):
        if self.letter not in letter_values:
            if self.multipliers[0] > 1:
                self.letter = f"{self.multipliers[0]}"
            elif self.multipliers[1] > 1:
                self.letter = f"{self.multipliers[1]+3}"
            else:
                self.letter = "0"
        return self.letter


class Board:
    def __init__(self):
        board = [Cell(x,y) for x, y in prod(range(1,16), range(1,16))]
        self.board = board
        for x,y in prod([1,8,15],[1,8,15]):
            if self[x,y] != self[8,8]:
                self[x,y].multipliers[1] = 3
        for n in range(2,6):
            self[n,n].multipliers[1] = self[n,16 - n].multipliers[1] = self[16 - n,n].multipliers[1] = self[16 - n, 16 - n].multipliers[1] = 2
        for x,y in prod([2,6,10,14],[2,6,10,14]):
            if self[x,y].multipliers[1] == 1:
                self[x,y].multipliers[0] = 3
            

    def __getitem__(self, coordinates):
        return [cell for cell in self.board if cell.x == coordinates[1] and cell.y == coordinates[0]][0]
    
    def __repr__(self):
        return f"{self.board}".replace(",", " ").replace("]", "").replace("[", "")


class Word:
    def __init__(self, word, start_pos, direction):
        for value in start_pos:
            if value == 0:
                print("Invalid word! -Out of range-")
        word = word.upper()
        self.word = word
        self.overlap_cells = []
        previous_board = deepcopy(board.board)
        # Checks if the word is in words.txt
        with open("words.txt") as all_words:
            if word not in [word.strip() for word in all_words.readlines()]:
                print("Invalid word! Not found in the scrabble dictionary")

        # Assigns all relevant cells a letter and adds them to a list
        for x, y, letter in zip(range(start_pos[0], start_pos[0]+len(word)+1), range(start_pos[1], start_pos[1]+len(word)+1), word):
            if y > 15 or x > 15:
                break
            if direction == "y":
                # Coordinates is the coordinate of the cell the word covers
                coordinates = (start_pos[0], y)
            elif direction == "x":
                coordinates = (x, start_pos[1])
            else:
                raise ValueError(f"Direction: {direction} is not valid")
            self.overlap_cells.append(board[coordinates])
            if board[coordinates].letter != letter and board[coordinates].letter != "0":
                print("Invalid word! Invalid intersection")
            board[coordinates].letter = letter
        if len(self.overlap_cells) != len(word):
            board.board = previous_board
            print("Invalid word! Out of range")

        self.value = 0
        final_multiplier = 1
        # Creates a value based on the letters and multipliers
        for index, cell in enumerate(self.overlap_cells):
            self.value += cell.multipliers[0] * letter_values[word[index]]
            if cell.multipliers[1] > 1:
                # Makes sure there is only one multiplier
                final_multiplier = cell.multipliers[1]
        self.value *= final_multiplier


board = Board()
test_word = Word("hello", (1, 1), "x")
print(test_word.value)
pprint(str(board), width=49)
