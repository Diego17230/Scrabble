from colorama import Fore, Style
from itertools import product as prod
from copy import deepcopy
letter_values = {'BLANK': 0, 'A': 1, 'B': 3, 'C': 3, 'D': 2, 'E': 1, 'F': 4, 'G': 2, 'H': 4, 'I': 1, 'J': 8, 'K': 5, 'L': 1, 'M': 3, 'N': 1, 'O': 1, 'P': 3, 'Q': 10, 'R': 1, 'S': 1, 'T': 1, 'U': 1, 'V': 8, 'W': 4, 'X': 8, 'Y': 4, 'Z': 10}


class Cell:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        # Value one is letter, value two is word
        self.multipliers = [1, 1]
        self.letter = "."

    def up(self):
        return board[self.x, self.y + 1]
    def down(self):
        return board[self.x, self.y - 1]
    def left(self):
        return board[self.x - 1, self.y]
    def right(self):
        return board[self.x + 1, self.y]
    
    def __repr__(self):
        if self.letter not in letter_values:
            if self.multipliers[0] > 1:
                self.letter = f"{self.multipliers[0]}"
            elif self.multipliers[1] > 1:
                self.letter = f"{self.multipliers[1]+3}"
            else:
                self.letter = "."
        if self.letter not in (".", "2", "3", "5", "6"):
                return f"{Fore.MAGENTA}{Style.BRIGHT}{self.letter}{Style.RESET_ALL}"
        elif self.letter == "2":
            return f"{Fore.CYAN}{Style.BRIGHT}{self.letter}{Style.RESET_ALL}"
        elif self.letter == "3":
            return f"{Fore.BLUE}{Style.BRIGHT}{self.letter}{Style.RESET_ALL}"
        elif self.letter == "5":
            return f"{Fore.YELLOW}{Style.BRIGHT}{self.letter}{Style.RESET_ALL}"
        elif self.letter == "6":
            return f"{Fore.RED}{Style.BRIGHT}{self.letter}{Style.RESET_ALL}"
        else:
            return self.letter


class Board:
    def __init__(self):
        board = [Cell(x,y) for x, y in prod(range(1,16), range(1,16))]
        self.board = board
        for x,y in prod([1,8,15],[1,8,15]):
            self[x,y].multipliers[1] = 3
        for n in range(2,6):
            self[n,n].multipliers[1] = self[n,16 - n].multipliers[1] = self[16 - n,n].multipliers[1] = self[16 - n, 16 - n].multipliers[1] = 2
        for x,y in prod([2,6,10,14],[2,6,10,14]):
            if self[x,y].multipliers == [1,1]:
                self[x,y].multipliers[0] = 3
        for x,y in prod([1,4,8,12,15],[1,4,8,12,15]):
            if self[x,y].multipliers == [1,1]:
                self[x,y].multipliers[0] = 2
        for n in (7,9):
            self[n,3].multipliers[0] = self[3,n].multipliers[0] = self[n,13].multipliers[0] = self[13,n].multipliers[0] = self[n,n].multipliers[0] = self[n,16 - n].multipliers[0] = 2
        self[8,8].multipliers = [1,1]
            

    def __getitem__(self, coordinates):
        return [cell for cell in self.board if cell.x == coordinates[1] and cell.y == coordinates[0]][0]
    
    def __repr__(self):
        text = "  " + "1 2 3 4 5 6 7 8 9 A B C D E F" + "\n1|"
        for i,cell in enumerate(self.board):
            text += f"{cell}|"
            if (i + 1) % 15 == 0:
                text += f"\n{hex((i+1)//15 + 1)[-1].upper()}|"
        return text[:-3].rstrip()


class Word:
    def __init__(self, word, start_pos, direction):
        for value in start_pos:
            if value == 0:
                print("Invalid word! -Out of range-")
        word = word.upper()
        self.word = word
        self.overlap_cells = []
        previous_board = deepcopy(board.board)
        # Checks if the word is in words.txt
        with open("words.txt") as all_words:
            if word not in [word.strip() for word in all_words.readlines()]:
                print("Invalid word! Not found in the scrabble dictionary")

        # Assigns all relevant cells a letter and adds them to a list
        for x, y, letter in zip(range(start_pos[0], start_pos[0]+len(word)+1), range(start_pos[1], start_pos[1]+len(word)+1), word):
            if y > 15 or x > 15:
                break
            if direction == "y":
                # Coordinates is the coordinate of the cell the word covers
                coordinates = (start_pos[0], y)
            elif direction == "x":
                coordinates = (x, start_pos[1])
            else:
                raise ValueError(f"Direction: {direction} is not valid")
            self.overlap_cells.append(board[coordinates])
            if board[coordinates].letter != letter and board[coordinates].letter != ".":
                print("Invalid word! Invalid intersection")
            board[coordinates].letter = letter
        if len(self.overlap_cells) != len(word):
            board.board = previous_board
            print("Invalid word! Out of range")

        self.value = 0
        final_multiplier = 1
        # Creates a value based on the letters and multipliers
        for index, cell in enumerate(self.overlap_cells):
            self.value += cell.multipliers[0] * letter_values[word[index]]
            if cell.multipliers[1] > 1:
                # Makes sure there is only one multiplier
                final_multiplier = cell.multipliers[1]
        self.value *= final_multiplier


board = Board()
test_word = Word("hello", (1, 1), "x")
print(test_word.value)
print(board)
