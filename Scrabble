from itertools import product as prod
from copy import deepcopy
from colorama import Fore, Style
letter_values = {'_': 0, 'A': 1, 'B': 3, 'C': 3, 'D': 2, 'E': 1, 'F': 4, 'G': 2, 'H': 4, 'I': 1, 'J': 8, 'K': 5, 'L': 1, 'M': 3, 'N': 1, 'O': 1, 'P': 3, 'Q': 10, 'R': 1, 'S': 1, 'T': 1, 'U': 1, 'V': 8, 'W': 4, 'X': 8, 'Y': 4, 'Z': 10, "·": 0}


class Cell:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        # Value one is letter, value two is word
        self.multipliers = [1, 1]
        self.letter = "·"

    def up(self):
        return board[self.x, self.y + 1]
    def down(self):
        return board[self.x, self.y - 1]
    def left(self):
        return board[self.x - 1, self.y]
    def right(self):
        return board[self.x + 1, self.y]

    def __repr__(self):
        if self.letter not in letter_values or self.letter == "·":
            if self.multipliers[0] > 1:
                self.letter = f"{self.multipliers[0]}"
            elif self.multipliers[1] > 1:
                self.letter = f"{self.multipliers[1]+3}"
            else:
                self.letter = "·"

        if self.letter not in ("·", "2", "3", "5", "6"):
            return f"{Fore.MAGENTA}{Style.BRIGHT}{self.letter}{Style.RESET_ALL}"
        elif self.letter == "2":
            return f"{Fore.CYAN}{Style.BRIGHT}{self.letter}{Style.RESET_ALL}"
        elif self.letter == "3":
            return f"{Fore.BLUE}{Style.BRIGHT}{self.letter}{Style.RESET_ALL}"
        elif self.letter == "5":
            return f"{Fore.YELLOW}{Style.BRIGHT}{self.letter}{Style.RESET_ALL}"
        elif self.letter == "6":
            return f"{Fore.RED}{Style.BRIGHT}{self.letter}{Style.RESET_ALL}"
        elif self == board[8,8] and self.multipliers == [1,1]:
            return f"{Fore.GREEN}{Style.BRIGHT}★{Style.RESET_ALL}"
        else:
            return self.letter


class Word:
    def __init__(self, word, start_pos, direction):
        self.word = word.upper()
        self.pos = start_pos
        self.direction = direction
        self.place(True)
        self.edit_word()
        self.overlap_cells = []

    def edit_word(self):
        place = input(f"Confirm placement for {self.word}? y/n \n")
        if place == "n":
            options = input("Do you want to rotate (r), change position (p), change word (w), or cancel (x) this word? \n")
            if options == "r":
                if self.direction == "y":
                    self.rotate("x")
                else:
                    self.rotate("y")
            elif options == "p":
                xy = input("What xy position, seperate by space. ").split()
                try:
                    self.change_pos(int(xy[0]), int(xy[1]))
                except ValueError:
                    self.change_pos(15, 15)
            elif options == "w":
                self.change_word(input("What is your new word? \n"))
            elif options == "x":
                del self
                return
            else:
                print(f"\n{Fore.RED}{Style.BRIGHT}Invalid input!{Style.RESET_ALL}")
            self.edit_word()
        elif place == "y":
            self.place()
        else:
            print(f"\n{Fore.RED}{Style.BRIGHT}Invalid input!{Style.RESET_ALL}")
            self.edit_word()

    def place(self, preview=False):
        error = False
        if not any(self.pos):
            # Checks if one of the positions is 0
            print(f"\n{Fore.RED}{Style.BRIGHT}Invalid word! Out of range: {self.pos}{Style.RESET_ALL}")
            error = True
        self.overlap_cells = []
        previous_board = deepcopy(board.board)

        # Assigns all relevant cells a letter and adds them to a list
        for x, y, letter, index in zip(range(self.pos[0], self.pos[0]+len(self.word)+1), range(self.pos[1], self.pos[1]+len(self.word)+1), self.word, range(len(self.word))):
            if y > 15 or x > 15:
                break
            if self.direction == "y":
                # Coordinates is the coordinate of the cell the word covers
                coordinates = (self.pos[0], y)
            else:
                coordinates = (x, self.pos[1])
            self.overlap_cells.append(board[coordinates])
            if board[coordinates].letter != letter and board[coordinates].letter not in ("·", "2", "3", "5", "6"):
                print(f"\n{Fore.RED}{Style.BRIGHT}Invalid word! -Invalid intersection at {coordinates}-{Style.RESET_ALL}")
                error = True
                board.board = previous_board
                if not preview:
                    return
                break
            board[coordinates].letter = letter
        if len(self.overlap_cells) != len(self.word):
            board.board = previous_board
            print(f"\n{Fore.RED}{Style.BRIGHT}Invalid word! -Out of range: {self.pos}-{Style.RESET_ALL}")
            error = True
            if not preview:
                return

        self.value = 0
        final_multiplier = 1
        # Creates a value based on the letters and multipliers
        for index, cell in enumerate(self.overlap_cells):
            try:
                self.value += cell.multipliers[0] * letter_values[self.word[index]]
            except KeyError:
                (f"\n{Fore.RED}{Style.BRIGHT}Invalid word! -Not found in the scrabble dictionary-{Style.RESET_ALL}")
                error = True
                board.board = previous_board
                if not preview:
                    self.value = 0
                    return
            if cell.multipliers[1] > 1:
                # Makes sure there is only one multiplier
                final_multiplier = cell.multipliers[1]
            cell.multipliers = [1, 1]
        self.value *= final_multiplier

        # Checks if the word is in words.txt
        with open("words.txt") as all_words:
            if self.word not in [word.strip() for word in all_words.readlines()]:
                print(f"\n{Fore.RED}{Style.BRIGHT}Invalid word! -Not found in the scrabble dictionary-{Style.RESET_ALL}")
                error = True
                board.board = previous_board
                if not preview:
                    self.value = 0
                    return

        if preview:
            print(f"\n{Fore.BLUE}{Style.BRIGHT}Preview:{Style.RESET_ALL}")
            if error:
                self.value = 0
            print(f"Expected word value: {self.value}")
            print(board)
            board.board = previous_board

    def rotate(self, xy: str):
        self.direction = xy
        self.place(True)

    def change_pos(self, x: int, y: int):
        self.pos = (x, y)
        self.place(True)
    
    def change_word(self, word: str):
        self.word = word.upper()
        self.place(True)


board = Board()
test_word = Word("hello", (1, 1), "x")
test_word2 = Word("hi", (10, 10), "x")
print(board)
